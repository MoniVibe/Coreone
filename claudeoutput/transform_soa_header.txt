#pragma once

#include <cstddef>
#include <cstdint>
#include <memory_resource>
#include <cassert>
#include <cstring>

namespace engine::components {

// Structure-of-Arrays transform component for efficient SIMD processing
// All arrays are 32-byte aligned for AVX2 compatibility
struct TransformSoA {
    // Position components
    float* posX = nullptr;
    float* posY = nullptr;
    float* posZ = nullptr;
    
    // Rotation quaternion components
    float* quatX = nullptr;
    float* quatY = nullptr;
    float* quatZ = nullptr;
    float* quatW = nullptr;
    
    // Scale components (optional, defaults to 1.0)
    float* scaleX = nullptr;
    float* scaleY = nullptr;
    float* scaleZ = nullptr;
    
    // Current number of active transforms and total capacity
    size_t count = 0;
    size_t capacity = 0;
    
    // Memory resource for allocation
    std::pmr::monotonic_buffer_resource* memory = nullptr;
    std::pmr::polymorphic_allocator<std::byte> allocator;
    
    // Alignment requirement for SIMD operations
    static constexpr size_t ALIGNMENT = 32;
    
    TransformSoA() : allocator(std::pmr::get_default_resource()) {}
    explicit TransformSoA(std::pmr::monotonic_buffer_resource* resource);
    ~TransformSoA();
    
    // Disable copy, allow move
    TransformSoA(const TransformSoA&) = delete;
    TransformSoA& operator=(const TransformSoA&) = delete;
    TransformSoA(TransformSoA&& other) noexcept;
    TransformSoA& operator=(TransformSoA&& other) noexcept;
    
    // Reserve capacity for N transforms
    void reserve(size_t n);
    
    // Get current size
    size_t size() const { return count; }
    
    // Check if index is valid
    bool valid(size_t i) const { return i < count; }
    
    // Get position at index
    void getPosition(size_t i, float& x, float& y, float& z) const;
    void setPosition(size_t i, float x, float y, float z);
    
    // Get quaternion at index
    void getQuaternion(size_t i, float& x, float& y, float& z, float& w) const;
    void setQuaternion(size_t i, float x, float y, float z, float w);
    
    // Get scale at index
    void getScale(size_t i, float& x, float& y, float& z) const;
    void setScale(size_t i, float x, float y, float z);
    
    // SIMD-friendly aligned load/store (4-wide)
    void loadPositionAligned4(size_t i, float* dst) const;
    void storePositionAligned4(size_set i, const float* src);
    
    void loadQuaternionAligned4(size_t i, float* dst) const;
    void storeQuaternionAligned4(size_t i, const float* src);
    
    // Add a new transform
    size_t add(float px, float py, float pz,
               float qx, float qy, float qz, float qw,
               float sx = 1.0f, float sy = 1.0f, float sz = 1.0f);
    
    // Remove transform at index (swap with last)
    void remove(size_t i);
    
    // Clear all transforms (keep capacity)
    void clear() { count = 0; }
    
    // Verify alignment for debugging
    void verifyAlignment() const;
    
private:
    void* allocateAligned(size_t size);
    void deallocate();
    void moveFrom(TransformSoA&& other) noexcept;
};

} // namespace engine::components